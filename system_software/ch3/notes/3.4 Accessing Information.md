# 3.4 Accessing Information

- Historically, It begins with the original `8086`, which had eight **16-bit** registers.
	- They had a specific purpose, so they got a name reflected how they were to be used.

| %ax | %bx | %cx | %dx | %si | %di | %bp | %sp |
| --- | --- | --- | --- | --- | --- | --- | --- |


	
- `IA32` comes next with a larger memory bits (**32-bit**)
- The regsters were therefore expanded to 32-bit regsters, labeled with prefix `e`

| %eax | %ebx | %ecx | %edx | %esi | %edi | %ebp | %esp |
| --- | --- | --- | --- | --- | --- | --- | --- |

- In the extension to `x96-64`, the original eight registers were expanded to 64-bit registers, and labeled with prefix `r` instead of `e`.

| %rax | %rbx | %rcx | %rdx | %rsi | %rdi | %rbp | %rsp |
| --- | --- | --- | --- | --- | --- | --- | --- |

- Even more, there are 8 new registers are added, so they needed a new naming conventions.
- they simply got numbers at the end with prefix `r` 

| %r8 | %r9 | %r10 | %r11 | %r12 | %r13 | %r14 | %r15 |
| --- | --- | --- | --- | --- | --- | --- | --- |

- So, in modern system, the computer can operate the instructions on various size of data stored in the registers

- Different registers typically serve different roles in the program.

## 3.4.1 Operand Specifiers
- Most instructions have one ore more `operand`, which could be a *source* or *destination* of the data.
- In here, we'll gonna take a look at `x86-64` operand forms.
- The *Source* value can be: *constants* or *read data* from memory or registers
- The *Result* value can be stored in either *memory* or *register*
- Thus, operands can be classified into three types.

| Type | Form | Operand Value | Name |
| --- | --- | --- | --- |
|Immediate| $\$Imm$ | $Imm$ | Immediate |
|Register | $r_a$| R[$r_a$] | Register |
|Memory| $Imm$ | M[$Imm$] | Absolute |
|Memory| ($r_a$) | M[R[$r_a$]] | Indirect |
|Memory| $Imm$($r_b$)|M[$Imm$+R[$r_b$]]| Indirect|
|Memory| ($r_b$, $r_i$)| M[R[$r_b$] + R[$r_i$]]| Indexed|
|Memory| $Imm$($r_b$, $r_i$)|M[$Imm$ + R[$r_b$] + R[$r_i$]]| Indexed
|Memory| (,$r_i$, $s$)| M[R[$r_i$] $\cdot s$]| Scaled indexed|
|Memory| $Imm$(,$r_i$, $s$)| M[$Imm$ + R[$r_i$] $\cdot s$]| Scaled Indexed|
|Memory| ($r_b$, $r_i$, $s$) | M[R[$r_b$] + R[$r_i$]$\cdot s$]| Scaled Indexed|
|Memory| $Imm$($r_b$, $r_i$, $s$)| M[$Imm$ + R[$r_b$] + R[$r_i$] $\cdot s$] | Scaled Indexed|

1. `Immediate`
	- In ATT format, `$0x100`
2. `Register`
	- The contents of the registers, one of the 16-, 8-, 4-, 2-, or 1- byte low-order portions of the register. 
	- In the above table, $r_a$ denotes an arbitrary register $a$
	- The value of the $r_a$ is denoted as R[$r_a$], viewing the set of registers as an array R indexed by register identifiers.
3. `Memory`
	- The address used to access some memory location often called the *effective address*
	- The memory could be considered as a large array, $M_b$[$Addr$] means $b$-byte value stored in memory starting at address $Addr$.
	- For the simplicity, drop the $b$
	- The general form is at the bottom of the table, $Imm$($r_b$, $r_i$, $s$).
		- $Imm$: Immediate offset
		- $r_b$: base register (must be 64-bit register)
		- $r_i$: index register (must be 64-bit register)
		- $s$: scalar factor (must be 1, 2, 4, or 8)
- So, the `*effective address*` is computed as below (in general form)
	- $Imm$ + R[$r_b$] + R[$r_i$] $\cdot s$

## 3.4.2 Data Movement Instructions
- Basically, these instructions are copying data from source location to destination source.
- The type of the operand is the matter.
- The *instruction class* (a group of instructions that performs the same operation) is `mov` class.
- These instructions copy data from a source location to a destination location **without** any transformation.

|Instruction|Effect|Description|
|---|---|---|
|$\text{movb}$|$D \leftarrow S$|Move byte|
|$\text{movw}$|$D \leftarrow S$|Move word|
|$\text{movl}$|$D \leftarrow S$|Move double word|
|$\text{movq}$|$D \leftarrow S$|Move quad word|
|$text{movabsq}$|$R \leftarrow I$|Move absolute quad word|

- The `source` operand designates a **value** that is *immediate*, *stored in a register*, *stored in memory*
- The `destination` operand designates a **location** that is either a *register* or a *memory address*
- There are `restriction` that a *move* instruction cannot have both operands refer to *memory location*
- Copying a value from a *memory* to another needs to be done by two instructions
	- Load the *source* value to the *register*
	- write the value to the *memory*
- `mov` instructions will update only the labeled portion(b, w, l, q) of the register which is designated as a *destination* except the `movl` instruction.
	- If `movl` has a *register* as a destination, It will set the high-order 4-byte of the register to 0.

```ATT
	movl $0x4050, %eax		Immediate--Register, 4 bytes
	movw %bp, %sp		Register--Register, 2 bytes
	movb (%rdi, %rcx), %al	Memory--Register, 1 byte
	movb $-17, (%esp)		Immediate--Memory, 1 byte
	movq %rax, -12(%rbp)	Register--Memory, 8 bytes
```

- The last one `mov-abs-q` instruction takes *Immediate* 64-bit value as a *source* and *Register* as a *destination*
	- The regular `movq` instruction can only have immediate source operands that can be represented as 32-bit two's-complement numbers.

- There are another `mov` class that from a *smaller source* to a *larger destination* instructions

|Instruction|Effect|Description|
|---|---|---|
|$\text{movzbw}$|$R \leftarrow \text{ZeroExtended}(S)$|Move zero-extended byte to word|
|$\text{movzbl}$|$R \leftarrow \text{ZeroExtended}(S)$|Move zero-extended byte to doulbe word|
|$\text{movzwl}$|$R \leftarrow \text{ZeroExtended}(S)$|Move zero-extended word to doulbe word|
|$\text{movzbq}$|$R \leftarrow \text{ZeroExtended}(S)$|Move zero-extended byte to quad word|
|$\text{movzwq}$|$R \leftarrow \text{ZeroExtended}(S)$|Move zero-extended word to quad word|

|Instruction|Effect|Description|
|---|---|---|
|$\text{movsbw}$|$R \leftarrow \text{SignExtended}(S)$|Move sign-extended byte to word|
|$\text{movsbl}$|$R \leftarrow \text{SignExtended}(S)$|Move sign-extended byte to doulbe word|
|$\text{movswl}$|$R \leftarrow \text{SignExtended}(S)$|Move sign-extended word to doulbe word|
|$\text{movsbq}$|$R \leftarrow \text{SignExtended}(S)$|Move sign-extended byte to quad word|
|$\text{movswq}$|$R \leftarrow \text{SignExtended}(S)$|Move sign-extended word to quad word|
|$\text{movslq}$|$R \leftarrow \text{SignExtended}(S)$|Move sign-extended double word to quad word|

- See that there is no `movzlq`, but it could be implemented using a `movl`
- There is a special instruction named `ctlq`

|Instruction|Effect|Description|
|---|---|---|
|$\text{ctlq}$|%rax $\leftarrow$ $\text{SignExtended}$(%eax)| Sign-extend %eax to %rax|

- The reason instruction `cltq` being used is that it has more compact encoding

## 3.4.3 Data Movement Example
```C
long exchange(long *xp, long y)
{
	long x = *xp;
	*xp = y;
	return x;
}
```

```
# long exchange(long *xp, long y)
# xp in %rdi, y in %rsi

1 exchange:
2	movq	(%rdi), %rax	# Get x at xp. Set as return value.
3	movq	%rsi, (%rdi)	# Store y at xp.
4	ret
```

- The **pointer** is just an address.
- Dereferencing a pointer involves copying that pointer into a register, and then using this register in a memory reference.
- The **local variables** are often kept in registers rather than stored in memory locations.
	- Accessing to *register* is much faster than *memory*

## 3.4.4 Pushing and Popping Stack Data
- The final two data movement operations.
	- `Push` and `Pop`
- **Stack**
	- `last-in, first-out` rule
	- *Top* is the end of the structure that the data is added or removed
	- *Top* has the lowest address of the *Stack*
	- The stack pointer, `%rsp` holds the address of the top stack element.
- The instruction `pushq` and `popq` is the implement of these instructions
	- They are *single operand instructions*, which are the *source* for pushing and the *destination* for popping
- `pushq`
	- Pushing a *quad word* size data onto the stack involves the first **decrementing** the stack pointer by 8 and then **writing** the value at the new *top-of-stack* address.
```assembly
# pushq %rbp
subq $8, %rsp		# Decrement stack pointer
movq %rbp, (%rsp)	# Store %rbp on stack
```

- `popq`
	- Popping a *quad word* size, on the other hand, **reading** the data from the *top-of-stack* first and then **increments** the stack pointer by 8.
```assembly
# popq %rax
movq (%rsp), %rax	# Read %rax from stack
addq %8, %rsp		# Increment stack pointer
```

- Since the stack is contained in the same memory as the program code and other forms of program data, programs can access *arbitrary positions within the stack* using the standard memory addressing methods
	- instruction `movq 8(%rsp), %rdx` will copy the *second quad word* from the stack to register %rdx
